<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>NBA Player Comparison Tool - HoopsHype</title>
    <meta name="description" content="Compare any two NBA players across 140+ categories including awards, stats, salaries, and more.">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background-color: #f5f5f5;
            padding: 20px;
            line-height: 1.6;
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            padding: 30px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        h1 {
            color: #1a1a1a;
            margin-bottom: 10px;
            font-size: 2.5em;
            text-align: center;
        }
        .subtitle {
            text-align: center;
            color: #666;
            margin-bottom: 30px;
            font-size: 1.1em;
        }
        .player-selector {
            display: grid;
            grid-template-columns: 1fr auto 1fr;
            gap: 20px;
            margin-bottom: 30px;
            align-items: center;
        }
        select {
            width: 100%;
            padding: 12px;
            font-size: 16px;
            border: 2px solid #ddd;
            border-radius: 6px;
            background-color: white;
            cursor: pointer;
            transition: border-color 0.3s;
        }
        select:hover { border-color: #007bff; }
        select:focus {
            outline: none;
            border-color: #007bff;
        }
        .vs-text {
            font-size: 24px;
            font-weight: bold;
            color: #666;
            text-align: center;
        }
        .compare-button {
            background-color: #007bff;
            color: white;
            border: none;
            padding: 15px 40px;
            font-size: 18px;
            border-radius: 6px;
            cursor: pointer;
            display: block;
            margin: 0 auto 30px;
            transition: background-color 0.3s;
        }
        .compare-button:hover { background-color: #0056b3; }
        .compare-button:disabled {
            background-color: #ccc;
            cursor: not-allowed;
        }
        .loading {
            text-align: center;
            padding: 40px;
            font-size: 18px;
            color: #666;
        }
        .spinner {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #007bff;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin: 20px auto;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        .score-summary {
            display: grid;
            grid-template-columns: 1fr auto 1fr;
            gap: 20px;
            margin-bottom: 30px;
            padding: 30px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border-radius: 12px;
            color: white;
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
        }
        .player-score { text-align: center; }
        .player-name-score {
            font-size: 20px;
            font-weight: 600;
            margin-bottom: 15px;
            opacity: 0.9;
        }
        .score-value {
            font-size: 56px;
            font-weight: bold;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }
        .score-divider {
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 36px;
            font-weight: 300;
            opacity: 0.7;
        }
        .category-section {
            margin-bottom: 50px;
        }
        .category-title {
            font-size: 24px;
            font-weight: 700;
            color: #1a1a1a;
            margin-bottom: 20px;
            padding-bottom: 12px;
            border-bottom: 4px solid #007bff;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        .comparison-row {
            display: grid;
            grid-template-columns: 2fr 3fr 1fr 3fr 2fr;
            gap: 15px;
            padding: 18px 20px;
            margin-bottom: 12px;
            border-radius: 8px;
            background-color: #fafafa;
            align-items: center;
            transition: transform 0.2s, box-shadow 0.2s;
        }
        .comparison-row:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
        }
        .comparison-row.winner-left {
            background: linear-gradient(90deg, #d4edda 0%, #fafafa 50%, #fafafa 100%);
            border-left: 4px solid #28a745;
        }
        .comparison-row.winner-right {
            background: linear-gradient(90deg, #fafafa 0%, #fafafa 50%, #d4edda 100%);
            border-right: 4px solid #28a745;
        }
        .comparison-row.tie {
            background: linear-gradient(90deg, #fff3cd 0%, #fafafa 50%, #fff3cd 100%);
            border-left: 4px solid #ffc107;
            border-right: 4px solid #ffc107;
        }
        .player-value {
            font-size: 19px;
            font-weight: 600;
            text-align: center;
            color: #333;
        }
        .player-value.winner {
            color: #28a745;
            font-size: 20px;
        }
        .metric-name {
            font-size: 15px;
            color: #555;
            text-align: center;
            font-weight: 500;
        }
        .no-data {
            color: #999;
            font-style: italic;
            font-weight: 400;
        }
        .share-url {
            margin-top: 40px;
            padding: 25px;
            background-color: #f8f9fa;
            border-radius: 8px;
            border: 1px solid #dee2e6;
        }
        .share-url h3 {
            margin-bottom: 15px;
            color: #333;
            font-size: 18px;
        }
        .share-url-input {
            width: 100%;
            padding: 12px;
            font-size: 14px;
            border: 2px solid #ddd;
            border-radius: 6px;
            font-family: 'Courier New', monospace;
            background-color: white;
            cursor: pointer;
        }
        .share-url-input:focus {
            outline: none;
            border-color: #007bff;
        }
        .error-message {
            background-color: #f8d7da;
            color: #721c24;
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 20px;
            text-align: center;
            border: 1px solid #f5c6cb;
        }
        @media (max-width: 768px) {
            h1 { font-size: 2em; }
            .player-selector { grid-template-columns: 1fr; }
            .vs-text {
                order: 1;
                margin: 15px 0;
            }
            .comparison-row {
                grid-template-columns: 1fr;
                gap: 8px;
                padding: 15px;
            }
            .player-value, .metric-name { text-align: left; }
            .score-summary {
                grid-template-columns: 1fr;
                gap: 15px;
            }
            .score-divider {
                order: 2;
                font-size: 28px;
            }
            .score-value { font-size: 42px; }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üèÄ NBA Player Comparison Tool</h1>
        <div class="subtitle">Compare any two NBA players across 140+ categories</div>

        <div id="loadingMessage" class="loading">
            <div class="spinner"></div>
            <div>Loading player database...</div>
        </div>

        <div id="mainContent" style="display: none;">
            <div class="player-selector">
                <div class="player-select-wrapper">
                    <select id="player1" onchange="updateShareURL()">
                        <option value="">Select Player 1...</option>
                    </select>
                </div>
                <div class="vs-text">VS</div>
                <div class="player-select-wrapper">
                    <select id="player2" onchange="updateShareURL()">
                        <option value="">Select Player 2...</option>
                    </select>
                </div>
            </div>

            <button class="compare-button" onclick="compareFromSelectors()" id="compareBtn">
                Compare Players
            </button>

            <div id="results"></div>
        </div>

        <div id="errorMessage" style="display: none;"></div>
    </div>

    <script>
        // CONFIGURATION: Using separate JSON files (under 25MB each)
        const DATA_BASE_URL = 'https://jsierrahoopshype.github.io/nba-player-data/';
        const DATA_FILES = {
            awards: 'awards.json',
            allStar: 'allStar.json',
            awardVotes: 'awardVotes.json',
            combine: 'combine.json',
            nba2k: 'nba2k.json',
            poSeries: 'poSeries.json',
            poStats: 'poStats.json',
            rsStats: 'rsStats.json',
            salaries: 'salaries.json',
            sneakers: 'sneakers.json',
            comparisons: 'comparisons.json'
        };

        let playerData = {};
        let players = [];
        let dataLoaded = false;

        // Load JSON data from GitHub
        async function loadData() {
            console.log('Loading player data from GitHub (JSON format)...');
            
            try {
                // Load all JSON files in parallel
                const results = await Promise.all([
                    fetch(DATA_BASE_URL + DATA_FILES.awards).then(r => r.json()),
                    fetch(DATA_BASE_URL + DATA_FILES.allStar).then(r => r.json()),
                    fetch(DATA_BASE_URL + DATA_FILES.awardVotes).then(r => r.json()),
                    fetch(DATA_BASE_URL + DATA_FILES.combine).then(r => r.json()),
                    fetch(DATA_BASE_URL + DATA_FILES.nba2k).then(r => r.json()),
                    fetch(DATA_BASE_URL + DATA_FILES.poSeries).then(r => r.json()),
                    fetch(DATA_BASE_URL + DATA_FILES.poStats).then(r => r.json()),
                    fetch(DATA_BASE_URL + DATA_FILES.rsStats).then(r => r.json()),
                    fetch(DATA_BASE_URL + DATA_FILES.salaries).then(r => r.json()),
                    fetch(DATA_BASE_URL + DATA_FILES.sneakers).then(r => r.json()),
                    fetch(DATA_BASE_URL + DATA_FILES.comparisons).then(r => r.json())
                ]);
                
                // Assign results to playerData
                playerData.awards = results[0];
                playerData.allStar = results[1];
                playerData.awardVotes = results[2];
                playerData.combine = results[3];
                playerData.nba2k = results[4];
                playerData.poSeries = results[5];
                playerData.poStats = results[6];
                playerData.rsStats = results[7];
                playerData.salaries = results[8];
                playerData.sneakers = results[9];
                playerData.comparisons = results[10];
                
                console.log('Data loaded successfully:', {
                    comparisons: playerData.comparisons.length,
                    awards: playerData.awards.length,
                    rsStats: playerData.rsStats.length
                });
                
                // Debug: Check sample data structure
                if (playerData.rsStats.length > 0) {
                    console.log('Sample RS-Stats row:', playerData.rsStats[0]);
                }
                if (playerData.awards.length > 0) {
                    console.log('Sample Awards row:', playerData.awards[0]);
                }
                
                // Debug: Test LeBron James data
                const lebronRS = playerData.rsStats.filter(r => r.PLAYER && r.PLAYER.includes('LeBron'));
                const lebronAwards = playerData.awards.filter(r => r['PLAYER / COACH'] && r['PLAYER / COACH'].includes('LeBron'));
                console.log('LeBron RS-Stats rows:', lebronRS.length);
                console.log('LeBron Awards rows:', lebronAwards.length);
                if (lebronRS.length > 0) {
                    console.log('LeBron RS sample:', lebronRS[0]);
                }
                if (lebronAwards.length > 0) {
                    console.log('LeBron Award sample:', lebronAwards[0]);
                }
                
                // Extract unique players
                const playersSet = new Set();
                
                playerData.rsStats.forEach(row => {
                    if (row.PLAYER) playersSet.add(row.PLAYER.trim());
                });
                
                playerData.awards.forEach(row => {
                    if (row['PLAYER / COACH']) playersSet.add(row['PLAYER / COACH'].trim());
                });
                
                players = Array.from(playersSet).sort();
                dataLoaded = true;
                
                console.log(`Found ${players.length} unique players`);
                
                return Promise.resolve();
                
            } catch (error) {
                console.error('Error loading data:', error);
                throw error;
            }
        }

        // Initialize
        window.addEventListener('DOMContentLoaded', async function() {
            showLoading(true);
            
            try {
                await loadData();
                
                const urlParams = new URLSearchParams(window.location.search);
                const p1 = urlParams.get('p1');
                const p2 = urlParams.get('p2');
                
                populatePlayerDropdowns();
                
                if (p1 && p2) {
                    const player1Name = formatPlayerName(p1);
                    const player2Name = formatPlayerName(p2);
                    
                    document.getElementById('player1').value = player1Name;
                    document.getElementById('player2').value = player2Name;
                    
                    setTimeout(() => compareFromSelectors(), 500);
                }
                
                showLoading(false);
                document.getElementById('mainContent').style.display = 'block';
            } catch (error) {
                showError('Failed to load player data. Error: ' + error.message);
                showLoading(false);
            }
        });

        function showLoading(show) {
            document.getElementById('loadingMessage').style.display = show ? 'block' : 'none';
        }

        function showError(message) {
            const errorDiv = document.getElementById('errorMessage');
            errorDiv.className = 'error-message';
            errorDiv.textContent = message;
            errorDiv.style.display = 'block';
        }

        function formatPlayerName(urlName) {
            return urlName.split('-').map(word => 
                word.charAt(0).toUpperCase() + word.slice(1).toLowerCase()
            ).join(' ');
        }

        function playerNameToURL(playerName) {
            return playerName.toLowerCase()
                .replace(/\s+/g, '-')
                .replace(/[^a-z0-9-]/g, '')
                .replace(/--+/g, '-');
        }

        function populatePlayerDropdowns() {
            const player1Select = document.getElementById('player1');
            const player2Select = document.getElementById('player2');
            
            players.forEach(player => {
                const option1 = document.createElement('option');
                option1.value = player;
                option1.textContent = player;
                player1Select.appendChild(option1);
                
                const option2 = document.createElement('option');
                option2.value = player;
                option2.textContent = player;
                player2Select.appendChild(option2);
            });
        }

        function updateShareURL() {
            const p1 = document.getElementById('player1').value;
            const p2 = document.getElementById('player2').value;
            
            if (p1 && p2) {
                const shareURL = `${window.location.origin}${window.location.pathname}?p1=${playerNameToURL(p1)}&p2=${playerNameToURL(p2)}`;
                return shareURL;
            }
            return '';
        }

        function compareFromSelectors() {
            const p1 = document.getElementById('player1').value;
            const p2 = document.getElementById('player2').value;
            
            if (!p1 || !p2) {
                alert('Please select both players');
                return;
            }
            
            if (p1 === p2) {
                alert('Please select different players');
                return;
            }
            
            comparePlayer(p1, p2);
        }

        function comparePlayer(player1Name, player2Name) {
            const resultsDiv = document.getElementById('results');
            resultsDiv.innerHTML = '<div class="loading"><div class="spinner"></div><div>Comparing players...</div></div>';
            
            setTimeout(() => {
                const results = performComparison(player1Name, player2Name);
                displayResults(results, player1Name, player2Name);
                
                const newURL = `${window.location.pathname}?p1=${playerNameToURL(player1Name)}&p2=${playerNameToURL(player2Name)}`;
                window.history.pushState({}, '', newURL);
            }, 100);
        }

        function performComparison(player1Name, player2Name) {
            let player1Score = 0;
            let player2Score = 0;
            const categories = {};
            let currentSection = null;
            
            playerData.comparisons.forEach(comp => {
                const category = comp['Comparison points'];
                const winCondition = comp['Who wins?'];
                const dataSource = comp['Wheres the data?']; // Fixed: no apostrophe
                
                // Check if this is a section header
                if (!winCondition && !dataSource) {
                    currentSection = category;
                    categories[currentSection] = [];
                    return;
                }
                
                if (!currentSection || !category) return;
                
                // Get player stats
                const p1Value = getPlayerStat(player1Name, category, dataSource);
                const p2Value = getPlayerStat(player2Name, category, dataSource);
                
                // Determine winner
                let winner = 'tie';
                if (p1Value !== null && p2Value !== null) {
                    const p1Num = parseFloat(String(p1Value).replace(/,/g, ''));
                    const p2Num = parseFloat(String(p2Value).replace(/,/g, ''));
                    
                    if (!isNaN(p1Num) && !isNaN(p2Num)) {
                        if (winCondition === 'Most') {
                            if (p1Num > p2Num) {
                                winner = 'player1';
                                player1Score++;
                            } else if (p2Num > p1Num) {
                                winner = 'player2';
                                player2Score++;
                            }
                        } else if (winCondition === 'Least') {
                            if (p1Num < p2Num) {
                                winner = 'player1';
                                player1Score++;
                            } else if (p2Num < p1Num) {
                                winner = 'player2';
                                player2Score++;
                            }
                        }
                    }
                }
                
                categories[currentSection].push({
                    metric: category,
                    player1Value: p1Value,
                    player2Value: p2Value,
                    winner: winner
                });
            });
            
            // Remove empty comparisons (where both players have no data)
            Object.keys(categories).forEach(sectionName => {
                categories[sectionName] = categories[sectionName].filter(item => 
                    item.player1Value !== null || item.player2Value !== null
                );
            });
            
            return {
                player1: player1Name,
                player2: player2Name,
                player1Score: player1Score,
                player2Score: player2Score,
                categories: categories
            };
        }

        function getPlayerStat(playerName, metric, dataSource) {
            if (!dataSource) return null;
            
            // Map metric to actual data field based on data source
            if (dataSource === 'Awards.csv') {
                return getAwardCount(playerName, metric);
            } else if (dataSource === 'RS-Stats.csv') {
                return getRegularSeasonStat(playerName, metric);
            } else if (dataSource === 'PO-Stats.csv') {
                return getPlayoffStat(playerName, metric);
            } else if (dataSource === 'PO-series.csv') {
                return getPlayoffSeriesStat(playerName, metric);
            } else if (dataSource === 'Salaries.csv') {
                return getSalaryStat(playerName, metric);
            } else if (dataSource === 'Combine.csv') {
                return getCombineStat(playerName, metric);
            } else if (dataSource === 'Award-Votes.csv') {
                return getVotingStat(playerName, metric);
            } else if (dataSource === 'Sneakers.csv') {
                return getSneakerCount(playerName);
            } else if (dataSource === 'NBA2K.csv') {
                return get2KRating(playerName, metric);
            } else if (dataSource === 'All-Star.csv') {
                return getAllStarContestWins(playerName, metric);
            }
            
            return null;
        }

        function getAwardCount(playerName, awardType) {
            // Handle combined awards
            if (awardType === 'All-NBA Selections') {
                const first = playerData.awards.filter(row => 
                    row['PLAYER / COACH'] === playerName && row.AWARD === 'All-NBA First Team'
                ).length;
                const second = playerData.awards.filter(row => 
                    row['PLAYER / COACH'] === playerName && row.AWARD === 'All-NBA Second Team'
                ).length;
                const third = playerData.awards.filter(row => 
                    row['PLAYER / COACH'] === playerName && row.AWARD === 'All-NBA Third Team'
                ).length;
                const total = first + second + third;
                return total > 0 ? total : null;
            }
            
            if (awardType === 'All-Defensive Team Selections') {
                const first = playerData.awards.filter(row => 
                    row['PLAYER / COACH'] === playerName && row.AWARD === 'All-Defensive First Team'
                ).length;
                const second = playerData.awards.filter(row => 
                    row['PLAYER / COACH'] === playerName && row.AWARD === 'All-Defensive Second Team'
                ).length;
                const total = first + second;
                return total > 0 ? total : null;
            }
            
            if (awardType === 'Olympic Medals') {
                const gold = playerData.awards.filter(row => 
                    row['PLAYER / COACH'] === playerName && row.AWARD === 'Olympic Gold'
                ).length;
                const silver = playerData.awards.filter(row => 
                    row['PLAYER / COACH'] === playerName && row.AWARD === 'Olympic Silver'
                ).length;
                const bronze = playerData.awards.filter(row => 
                    row['PLAYER / COACH'] === playerName && row.AWARD === 'Olympic Bronze'
                ).length;
                const total = gold + silver + bronze;
                return total > 0 ? total : null;
            }
            
            if (awardType === 'World Cup Medals') {
                const gold = playerData.awards.filter(row => 
                    row['PLAYER / COACH'] === playerName && row.AWARD === 'World Cup Gold'
                ).length;
                const silver = playerData.awards.filter(row => 
                    row['PLAYER / COACH'] === playerName && row.AWARD === 'World Cup Silver'
                ).length;
                const bronze = playerData.awards.filter(row => 
                    row['PLAYER / COACH'] === playerName && row.AWARD === 'World Cup Bronze'
                ).length;
                const total = gold + silver + bronze;
                return total > 0 ? total : null;
            }
            
            // Regular award count
            const playerAwards = playerData.awards.filter(row => 
                row['PLAYER / COACH'] === playerName && row.AWARD === awardType
            );
            return playerAwards.length > 0 ? playerAwards.length : null;
        }

        function getRegularSeasonStat(playerName, metric) {
            const playerRows = playerData.rsStats.filter(row => row.PLAYER === playerName);
            if (playerRows.length === 0) return null;
            
            // Map metric to column name
            const columnMap = {
                'Points per game': 'PTS / G',
                'Rebounds per game': 'REB / G',
                'Assists per game': 'AST / G',
                'Steals per game': 'STL / G',
                'Blocks per game': 'BLK / G',
                'Field Goal %': 'FG%',
                'Three Point %': '3P%',
                'Free Throw %': 'FT%',
                'Turnovers per game': 'TOV / G',
                'Games': 'GP',
                'Points': 'PTS',
                'Rebounds': 'REB',
                'Assists': 'AST',
                'Steals': 'STL',
                'Blocks': 'BLK',
                'Turnovers': 'TOV',
                '3P%': '3P%'
            };
            
            // Season peak metrics - find highest single-season average
            const peakMetrics = {
                'Points per game peak': 'PTS / G',
                'Rebounds per game peak': 'REB / G',
                'Assists per game peak': 'AST / G',
                'Steals per game peak': 'STL / G',
                'Blocks per game peak': 'BLK / G',
                'Field Goal % peak': 'FG%',
                'Three Point % peak': '3P%',
                'Free Throw % peak': 'FT%',
                'Turnovers per game peak': 'TOV / G'
            };
            
            // Check if this is a peak metric
            if (peakMetrics[metric]) {
                const column = peakMetrics[metric];
                let maxValue = -Infinity;
                
                playerRows.forEach(row => {
                    let val = row[column];
                    
                    // Handle percentage strings (remove % if present)
                    if (typeof val === 'string') {
                        val = val.replace('%', '');
                    }
                    
                    val = parseFloat(val);
                    
                    if (!isNaN(val) && val > maxValue) {
                        maxValue = val;
                    }
                });
                
                if (maxValue > -Infinity) {
                    // For percentages, format as XX.XX%
                    if (metric.includes('%')) {
                        return maxValue.toFixed(1) + '%';
                    }
                    return maxValue.toFixed(1);
                }
                return null;
            }
            
            const column = columnMap[metric];
            if (!column) return null;
            
            // For per-game stats, calculate total/games
            if (metric.includes('per game')) {
                const baseStatMap = {
                    'Points per game': 'PTS',
                    'Rebounds per game': 'REB',
                    'Assists per game': 'AST',
                    'Steals per game': 'STL',
                    'Blocks per game': 'BLK',
                    'Turnovers per game': 'TOV'
                };
                
                const totalColumn = baseStatMap[metric];
                if (!totalColumn) return null;
                
                let totalStat = 0;
                let totalGames = 0;
                
                playerRows.forEach(row => {
                    const stat = parseFloat(row[totalColumn]);
                    const games = parseFloat(row['GP']);
                    if (!isNaN(stat) && !isNaN(games)) {
                        totalStat += stat;
                        totalGames += games;
                    }
                });
                
                return totalGames > 0 ? (totalStat / totalGames).toFixed(1) : null;
            }
            
            // For percentages, calculate weighted average
            if (metric.includes('%')) {
                const percentageMap = {
                    'Field Goal %': { pct: 'FG%', made: 'FGM', att: 'FGA' },
                    'Three Point %': { pct: '3P%', made: '3P', att: '3PA' },
                    'Free Throw %': { pct: 'FT%', made: 'FTM', att: 'FTA' },
                    '3P%': { pct: '3P%', made: '3P', att: '3PA' }
                };
                
                const pctInfo = percentageMap[metric];
                if (!pctInfo) return null;
                
                let totalMade = 0;
                let totalAtt = 0;
                
                playerRows.forEach(row => {
                    const made = parseFloat(row[pctInfo.made]);
                    const att = parseFloat(row[pctInfo.att]);
                    if (!isNaN(made) && !isNaN(att)) {
                        totalMade += made;
                        totalAtt += att;
                    }
                });
                
                if (totalAtt > 0) {
                    const pct = (totalMade / totalAtt) * 100;
                    return pct.toFixed(1) + '%';
                }
                return null;
            }
            
            // For totals, sum up
            let total = 0;
            playerRows.forEach(row => {
                const val = parseFloat(row[column]);
                if (!isNaN(val)) {
                    total += val;
                }
            });
            return total > 0 ? Math.round(total) : null;
        }

        function getPlayoffStat(playerName, metric) {
            const playerRows = playerData.poStats.filter(row => row.PLAYER === playerName);
            if (playerRows.length === 0) return null;
            
            // Similar to regular season stats
            const columnMap = {
                'Points per game PO': 'PTS / G',
                'Rebounds per game PO': 'REB / G',
                'Assists per game PO': 'AST / G',
                'Steals per game PO': 'STL / G',
                'Blocks per game PO': 'BLK / G',
                'Field Goal % PO': 'FG%',
                'Three Point % PO': '3P%',
                'Free Throw % PO': 'FT%',
                'Turnovers per game PO': 'TOV / G',
                'Games PO': 'GP',
                'Points PO': 'PTS',
                'Rebounds PO': 'REB',
                'Assists PO': 'AST',
                'Steals PO': 'STL',
                'Blocks PO': 'BLK',
                'Turnovers PO': 'TOV'
            };
            
            // Playoff peak metrics - find highest single-postseason average
            const peakMetrics = {
                'Points per game PO peak': 'PTS / G',
                'Rebounds per game PO peak': 'REB / G',
                'Assists per game PO peak': 'AST / G',
                'Steals per game PO peak': 'STL / G',
                'Blocks per game PO peak': 'BLK / G',
                'Field Goal % PO peak': 'FG%',
                'Three Point % PO peak': '3P%',
                'Free Throw % PO peak': 'FT%',
                'Turnovers per game PO peak': 'TOV / G'
            };
            
            // Check if this is a peak metric
            if (peakMetrics[metric]) {
                const column = peakMetrics[metric];
                let maxValue = -Infinity;
                
                playerRows.forEach(row => {
                    let val = row[column];
                    
                    // Handle percentage strings (remove % if present)
                    if (typeof val === 'string') {
                        val = val.replace('%', '');
                    }
                    
                    val = parseFloat(val);
                    
                    if (!isNaN(val) && val > maxValue) {
                        maxValue = val;
                    }
                });
                
                if (maxValue > -Infinity) {
                    // For percentages, format as XX.XX%
                    if (metric.includes('%')) {
                        return maxValue.toFixed(1) + '%';
                    }
                    return maxValue.toFixed(1);
                }
                return null;
            }
            
            const column = columnMap[metric];
            if (!column) return null;
            
            // For per-game stats, calculate total/games
            if (metric.includes('per game')) {
                const baseStatMap = {
                    'Points per game PO': 'PTS',
                    'Rebounds per game PO': 'REB',
                    'Assists per game PO': 'AST',
                    'Steals per game PO': 'STL',
                    'Blocks per game PO': 'BLK',
                    'Turnovers per game PO': 'TOV'
                };
                
                const totalColumn = baseStatMap[metric];
                if (!totalColumn) return null;
                
                let totalStat = 0;
                let totalGames = 0;
                
                playerRows.forEach(row => {
                    const stat = parseFloat(row[totalColumn]);
                    const games = parseFloat(row['GP']);
                    if (!isNaN(stat) && !isNaN(games)) {
                        totalStat += stat;
                        totalGames += games;
                    }
                });
                
                return totalGames > 0 ? (totalStat / totalGames).toFixed(1) : null;
            }
            
            // For percentages, calculate weighted average
            if (metric.includes('%')) {
                const percentageMap = {
                    'Field Goal % PO': { pct: 'FG%', made: 'FGM', att: 'FGA' },
                    'Three Point % PO': { pct: '3P%', made: '3P', att: '3PA' },
                    'Free Throw % PO': { pct: 'FT%', made: 'FTM', att: 'FTA' }
                };
                
                const pctInfo = percentageMap[metric];
                if (!pctInfo) return null;
                
                let totalMade = 0;
                let totalAtt = 0;
                
                playerRows.forEach(row => {
                    const made = parseFloat(row[pctInfo.made]);
                    const att = parseFloat(row[pctInfo.att]);
                    if (!isNaN(made) && !isNaN(att)) {
                        totalMade += made;
                        totalAtt += att;
                    }
                });
                
                if (totalAtt > 0) {
                    const pct = (totalMade / totalAtt) * 100;
                    return pct.toFixed(1) + '%';
                }
                return null;
            }
            
            // For totals, sum up
            let total = 0;
            playerRows.forEach(row => {
                const val = parseFloat(row[column]);
                if (!isNaN(val)) {
                    total += val;
                }
            });
            return total > 0 ? Math.round(total) : null;
        }

        function getPlayoffSeriesStat(playerName, metric) {
            const playerRow = playerData.poSeries.find(row => row.NAME === playerName);
            if (!playerRow) return null;
            
            const columnMap = {
                'First Round': 'W',
                'Conference Semis': 'W',
                'Conference Finals': 'W',
                'Finalist': 'W',
                'Champion': 'W',
                'Playoff series played': 'TOT',
                'Playoff series won': 'W',
                'Playoff series win %': '% W'
            };
            
            // This is simplified - you'd need more logic here
            return playerRow.W || playerRow['% W'] || null;
        }

        function getSalaryStat(playerName, metric) {
            const playerRows = playerData.salaries.filter(row => row.PLAYER === playerName);
            if (playerRows.length === 0) return null;
            
            const salaries = [];
            playerRows.forEach(row => {
                // Column name is "SALARY" (all caps)
                const salary = parseFloat(String(row.SALARY || row.Salary || '').replace(/[$,]/g, ''));
                if (!isNaN(salary) && salary > 0) {
                    salaries.push(salary);
                }
            });
            
            if (salaries.length === 0) return null;
            
            if (metric === 'Career earnings') {
                const total = salaries.reduce((sum, val) => sum + val, 0);
                return '$' + total.toLocaleString();
            }
            
            if (metric === 'Average salary') {
                const avg = salaries.reduce((sum, val) => sum + val, 0) / salaries.length;
                return '$' + Math.round(avg).toLocaleString();
            }
            
            if (metric === 'Highest salary') {
                const max = Math.max(...salaries);
                return '$' + max.toLocaleString();
            }
            
            if (metric === 'Lowest salary') {
                const min = Math.min(...salaries);
                return '$' + min.toLocaleString();
            }
            
            return null;
        }

        function getCombineStat(playerName, metric) {
            const playerRow = playerData.combine.find(row => row.PLAYER === playerName);
            if (!playerRow) return null;
            
            const columnMap = {
                'Body fat': 'BODY FAT %',
                'Hand size': 'HAND SIZE',
                'Height without shoes': 'HEIGHT W/O SHOES',
                'Standing reach': 'STANDING REACH',
                'Weight': 'WEIGHT (LBS)',
                'Wingspan': 'WINGSPAN',
                'Lane agility time': 'LANE AGILITY',
                'Shuttle run': 'SHUTTLE RUN',
                'Three quarter sprint': '3/4 SPRINT',
                'Standing vertical leap': 'STANDING VERT',
                'Max vertical leap': 'MAX VERT',
                'Max bench press': 'MAX BENCH',
                'Height': 'HEIGHT'
            };
            
            const column = columnMap[metric];
            if (!column) return null;
            
            const value = playerRow[column];
            return value && value.trim() !== '' ? value : null;
        }

        function getVotingStat(playerName, metric) {
            const playerVotes = playerData.awardVotes.filter(row => row.PLAYER === playerName);
            
            // Best awards ranking - find lowest (best) rank for each award
            const awardRankingMap = {
                'Most Valuable Player': 'MVP',
                'Defensive Player of the Year': 'DPOY',
                'Rookie of the Year': 'ROY',
                'Most Improved Player': 'MIP'
            };
            
            if (awardRankingMap[metric]) {
                const awardType = awardRankingMap[metric];
                const relevantVotes = playerVotes.filter(row => row.AWARD === awardType);
                
                if (relevantVotes.length === 0) return null;
                
                let bestRank = Infinity;
                relevantVotes.forEach(row => {
                    const rank = parseInt(row.RNK);
                    if (!isNaN(rank) && rank < bestRank) {
                        bestRank = rank;
                    }
                });
                
                return bestRank < Infinity ? bestRank : null;
            }
            
            // Years receiving votes
            const yearsVotesMap = {
                'Years with MVP votes': 'MVP',
                'Years with DPOY votes': 'DPOY',
                'Years with ROY votes': 'ROY',
                'Years with Sixth Man votes': 'Sixth Man',
                'Years with MIP votes': 'MIP'
            };
            
            if (yearsVotesMap[metric]) {
                const awardType = yearsVotesMap[metric];
                const relevantVotes = playerVotes.filter(row => row.AWARD === awardType);
                return relevantVotes.length > 0 ? relevantVotes.length : null;
            }
            
            return null;
        }

        function getSneakerCount(playerName) {
            const playerRow = playerData.sneakers.find(row => row.Player === playerName);
            return playerRow ? playerRow['# of shoes'] : null;
        }

        function get2KRating(playerName, metric) {
            const playerRow = playerData.nba2k.find(row => 
                row['Full Name'] === playerName || 
                row['First Name'] + ' ' + row['Last Name'] === playerName
            );
            
            if (!playerRow) return null;
            
            // Collect all ratings
            const ratings = [];
            for (let key in playerRow) {
                if (key.startsWith('2K') || key.startsWith('2k')) {
                    const val = parseInt(playerRow[key]);
                    if (!isNaN(val)) {
                        ratings.push(val);
                    }
                }
            }
            
            if (ratings.length === 0) return null;
            
            if (metric === 'Average career rating') {
                const avg = ratings.reduce((sum, val) => sum + val, 0) / ratings.length;
                return avg.toFixed(1);
            }
            
            if (metric === 'Highest rating') {
                return Math.max(...ratings);
            }
            
            if (metric === 'Lowest rating') {
                return Math.min(...ratings);
            }
            
            return null;
        }

        function getAllStarContestWins(playerName, metric) {
            const playerWins = playerData.allStar.filter(row => 
                row.NAME === playerName && row['WINNER?'] === 'WINNER'
            );
            
            if (metric === 'Dunk Contest') {
                return playerWins.filter(r => r.CONTEST === 'Dunk Contest').length || null;
            } else if (metric === 'Three-Point Contest') {
                return playerWins.filter(r => r.CONTEST === 'Three-Point Contest').length || null;
            } else if (metric === 'Skills Challenge') {
                return playerWins.filter(r => r.CONTEST === 'Skills Challenge').length || null;
            }
            
            return null;
        }

        function displayResults(results, player1Name, player2Name) {
            const resultsDiv = document.getElementById('results');
            
            let html = `
                <div class="score-summary">
                    <div class="player-score">
                        <div class="player-name-score">${player1Name}</div>
                        <div class="score-value">${results.player1Score}</div>
                    </div>
                    <div class="score-divider">‚Äì</div>
                    <div class="player-score">
                        <div class="player-name-score">${player2Name}</div>
                        <div class="score-value">${results.player2Score}</div>
                    </div>
                </div>
            `;
            
            const shareURL = updateShareURL();
            html += `
                <div class="share-url">
                    <h3>üì§ Share This Comparison</h3>
                    <input type="text" class="share-url-input" value="${shareURL}" readonly onclick="this.select(); try { document.execCommand('copy'); alert('URL copied!'); } catch(e) { console.log('Copy failed'); }">
                </div>
            `;
            
            // Display categories
            Object.keys(results.categories).forEach(categoryName => {
                const items = results.categories[categoryName];
                if (items.length === 0) return;
                
                html += `<div class="category-section">
                    <div class="category-title">${categoryName}</div>`;
                
                items.forEach(item => {
                    const rowClass = item.winner === 'player1' ? 'winner-left' : 
                                    item.winner === 'player2' ? 'winner-right' : 'tie';
                    
                    const p1Class = item.winner === 'player1' ? 'player-value winner' : 'player-value';
                    const p2Class = item.winner === 'player2' ? 'player-value winner' : 'player-value';
                    
                    const p1Display = item.player1Value !== null ? item.player1Value : '<span class="no-data">‚Äì</span>';
                    const p2Display = item.player2Value !== null ? item.player2Value : '<span class="no-data">‚Äì</span>';
                    
                    html += `
                        <div class="comparison-row ${rowClass}">
                            <div class="${p1Class}">${p1Display}</div>
                            <div class="player-value" style="font-weight: normal; font-size: 16px;">${player1Name}</div>
                            <div class="metric-name">${item.metric}</div>
                            <div class="player-value" style="font-weight: normal; font-size: 16px;">${player2Name}</div>
                            <div class="${p2Class}">${p2Display}</div>
                        </div>
                    `;
                });
                
                html += `</div>`;
            });
            
            resultsDiv.innerHTML = html;
        }
    </script>
</body>
</html>
