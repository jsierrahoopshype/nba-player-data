<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>NBA Player Comparison Tool - HoopsHype</title>
    <meta name="description" content="Compare any two NBA players across 140+ categories including awards, stats, salaries, and more.">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background-color: #f5f5f5;
            padding: 20px;
            line-height: 1.6;
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            padding: 30px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        h1 {
            color: #1a1a1a;
            margin-bottom: 10px;
            font-size: 2.5em;
            text-align: center;
        }
        .subtitle {
            text-align: center;
            color: #666;
            margin-bottom: 30px;
            font-size: 1.1em;
        }
        .player-selector {
            display: grid;
            grid-template-columns: 1fr auto 1fr;
            gap: 20px;
            margin-bottom: 30px;
            align-items: center;
        }
        .player-autocomplete {
            width: 100%;
            padding: 12px;
            font-size: 16px;
            border: 2px solid #ddd;
            border-radius: 6px;
            background-color: white;
            transition: border-color 0.3s;
        }
        .player-autocomplete:hover { border-color: #007bff; }
        .player-autocomplete:focus {
            outline: none;
            border-color: #007bff;
        }
        .player-select-wrapper {
            position: relative;
        }
        .autocomplete-suggestions {
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            background: white;
            border: 2px solid #007bff;
            border-top: none;
            border-radius: 0 0 6px 6px;
            max-height: 300px;
            overflow-y: auto;
            z-index: 1000;
            display: none;
        }
        .autocomplete-suggestion {
            padding: 10px 12px;
            cursor: pointer;
            border-bottom: 1px solid #eee;
        }
        .autocomplete-suggestion:hover {
            background-color: #f0f8ff;
        }
        .autocomplete-suggestion:last-child {
            border-bottom: none;
        }
        .vs-text {
            font-size: 24px;
            font-weight: bold;
            color: #666;
            text-align: center;
        }
        .compare-button {
            background-color: #007bff;
            color: white;
            border: none;
            padding: 15px 40px;
            font-size: 18px;
            border-radius: 6px;
            cursor: pointer;
            display: block;
            margin: 0 auto 30px;
            transition: background-color 0.3s;
        }
        .compare-button:hover { background-color: #0056b3; }
        .compare-button:disabled {
            background-color: #ccc;
            cursor: not-allowed;
        }
        .loading {
            text-align: center;
            padding: 40px;
            font-size: 18px;
            color: #666;
        }
        .spinner {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #007bff;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin: 20px auto;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        .score-summary {
            display: grid;
            grid-template-columns: 1fr auto 1fr;
            gap: 20px;
            margin-bottom: 30px;
            padding: 30px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border-radius: 12px;
            color: white;
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
        }
        .player-score { text-align: center; }
        .player-name-score {
            font-size: 20px;
            font-weight: 600;
            margin-bottom: 15px;
            opacity: 0.9;
        }
        .score-value {
            font-size: 56px;
            font-weight: bold;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }
        .score-divider {
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 36px;
            font-weight: 300;
            opacity: 0.7;
        }
        .category-section {
            margin-bottom: 50px;
        }
        .category-title {
            font-size: 24px;
            font-weight: 700;
            color: #1a1a1a;
            margin-bottom: 20px;
            padding-bottom: 12px;
            border-bottom: 4px solid #007bff;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        .section-score {
            font-size: 16px;
            font-weight: 600;
            color: #666;
            margin-top: 8px;
            text-align: left;
        }
        .suggestions-section {
            background: #f8f9fa;
            border-radius: 8px;
            padding: 25px;
            margin: 30px 0;
        }
        .suggestion-btn {
            background: #007bff;
            color: white;
            border: none;
            padding: 12px 20px;
            border-radius: 6px;
            font-size: 15px;
            font-weight: 600;
            cursor: pointer;
            transition: background 0.2s;
        }
        .suggestion-btn:hover {
            background: #0056b3;
        }
        .comparison-row {
            display: grid;
            grid-template-columns: 2fr 3fr 1fr 3fr 2fr;
            gap: 15px;
            padding: 18px 20px;
            margin-bottom: 12px;
            border-radius: 8px;
            background-color: #fafafa;
            align-items: center;
            transition: transform 0.2s, box-shadow 0.2s;
        }
        .comparison-row:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
        }
        .comparison-row.winner-left {
            background: linear-gradient(90deg, #d4edda 0%, #fafafa 50%, #fafafa 100%);
            border-left: 4px solid #28a745;
        }
        .comparison-row.winner-right {
            background: linear-gradient(90deg, #fafafa 0%, #fafafa 50%, #d4edda 100%);
            border-right: 4px solid #28a745;
        }
        .comparison-row.tie {
            background: linear-gradient(90deg, #fff3cd 0%, #fafafa 50%, #fff3cd 100%);
            border-left: 4px solid #ffc107;
            border-right: 4px solid #ffc107;
        }
        .player-value {
            font-size: 19px;
            font-weight: 600;
            text-align: center;
            color: #333;
        }
        .player-value.winner {
            color: #28a745;
            font-size: 20px;
        }
        .metric-name {
            font-size: 15px;
            color: #555;
            text-align: center;
            font-weight: 500;
        }
        .no-data {
            color: #999;
            font-style: italic;
            font-weight: 400;
        }
        .share-url {
            margin-top: 40px;
            padding: 25px;
            background-color: #f8f9fa;
            border-radius: 8px;
            border: 1px solid #dee2e6;
        }
        .share-url h3 {
            margin-bottom: 15px;
            color: #333;
            font-size: 18px;
        }
        .share-url-input {
            width: 100%;
            padding: 12px;
            font-size: 14px;
            border: 2px solid #ddd;
            border-radius: 6px;
            font-family: 'Courier New', monospace;
            background-color: white;
            cursor: pointer;
        }
        .share-url-input:focus {
            outline: none;
            border-color: #007bff;
        }
        .error-message {
            background-color: #f8d7da;
            color: #721c24;
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 20px;
            text-align: center;
            border: 1px solid #f5c6cb;
        }
        @media (max-width: 768px) {
            h1 { font-size: 2em; }
            .player-selector { grid-template-columns: 1fr; }
            .vs-text {
                order: 1;
                margin: 15px 0;
            }
            .comparison-row {
                grid-template-columns: 1fr;
                gap: 8px;
                padding: 15px;
            }
            .player-value, .metric-name { text-align: left; }
            .score-summary {
                grid-template-columns: 1fr;
                gap: 15px;
            }
            .score-divider {
                order: 2;
                font-size: 28px;
            }
            .score-value { font-size: 42px; }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üèÄ NBA Player Comparison Tool</h1>
        <div class="subtitle">Compare any two NBA players across 140+ categories</div>

        <div id="loadingMessage" class="loading">
            <div class="spinner"></div>
            <div>Loading player database...</div>
        </div>

        <div id="mainContent" style="display: none;">
            <!-- Player selector at top -->
            <div class="player-selector">
                <div class="player-select-wrapper">
                    <input type="text" id="player1-top" class="player-autocomplete" placeholder="Type player name...">
                    <div id="suggestions1-top" class="autocomplete-suggestions"></div>
                </div>
                <div class="vs-text">VS</div>
                <div class="player-select-wrapper">
                    <input type="text" id="player2-top" class="player-autocomplete" placeholder="Type player name...">
                    <div id="suggestions2-top" class="autocomplete-suggestions"></div>
                </div>
            </div>

            <button class="compare-button" onclick="compareFromInputs()" id="compareBtn">
                Compare Players
            </button>
            
            <div id="results"></div>
            
            <!-- Player selector at bottom -->
            <div class="player-selector" style="margin-top: 40px;">
                <div class="player-select-wrapper">
                    <input type="text" id="player1-bottom" class="player-autocomplete" placeholder="Type player name...">
                    <div id="suggestions1-bottom" class="autocomplete-suggestions"></div>
                </div>
                <div class="vs-text">VS</div>
                <div class="player-select-wrapper">
                    <input type="text" id="player2-bottom" class="player-autocomplete" placeholder="Type player name...">
                    <div id="suggestions2-bottom" class="autocomplete-suggestions"></div>
                </div>
            </div>

            <button class="compare-button" onclick="compareFromInputs()" style="margin-top: 20px;">
                Compare Players
            </button>
        </div>

        <div id="errorMessage" style="display: none;"></div>
    </div>

    <script>
        // CONFIGURATION: Using separate JSON files (under 25MB each)
        const DATA_BASE_URL = 'https://jsierrahoopshype.github.io/nba-player-data/';
        const DATA_FILES = {
            awards: 'awards.json',
            allStar: 'allStar.json',
            awardVotes: 'awardVotes.json',
            combine: 'combine-v3.json',
            nba2k: 'nba2k.json',
            poSeries: 'poSeries.json',
            poStats: 'poStats.json',
            rsStats: 'rsStats.json',
            salaries: 'salaries.json',
            sneakers: 'sneakers.json',
            comparisons: 'comparisons.json',
            allStarsData: 'allstars-data.json'
        };

        let playerData = {};
        let players = [];
        let dataLoaded = false;

        // Load JSON data from GitHub
        async function loadData() {
            console.log('Loading player data from GitHub (JSON format)...');
            
            try {
                // Add cache-busting timestamp to force fresh loads
                const timestamp = Date.now();
                const cacheBust = `?t=${timestamp}`;
                
                // Load all JSON files in parallel
                const results = await Promise.all([
                    fetch(DATA_BASE_URL + DATA_FILES.awards + cacheBust).then(r => r.json()),
                    fetch(DATA_BASE_URL + DATA_FILES.allStar + cacheBust).then(r => r.json()),
                    fetch(DATA_BASE_URL + DATA_FILES.awardVotes + cacheBust).then(r => r.json()),
                    fetch(DATA_BASE_URL + DATA_FILES.combine + cacheBust).then(r => r.json()),
                    fetch(DATA_BASE_URL + DATA_FILES.nba2k + cacheBust).then(r => r.json()),
                    fetch(DATA_BASE_URL + DATA_FILES.poSeries + cacheBust).then(r => r.json()),
                    fetch(DATA_BASE_URL + DATA_FILES.poStats + cacheBust).then(r => r.json()),
                    fetch(DATA_BASE_URL + DATA_FILES.rsStats + cacheBust).then(r => r.json()),
                    fetch(DATA_BASE_URL + DATA_FILES.salaries + cacheBust).then(r => r.json()),
                    fetch(DATA_BASE_URL + DATA_FILES.sneakers + cacheBust).then(r => r.json()),
                    fetch(DATA_BASE_URL + DATA_FILES.comparisons + cacheBust).then(r => r.json())
                ]);
                
                // Assign results to playerData
                playerData.awards = results[0];
                playerData.allStar = results[1];
                playerData.awardVotes = results[2];
                playerData.combine = results[3];
                playerData.nba2k = results[4];
                playerData.poSeries = results[5];
                playerData.poStats = results[6];
                playerData.rsStats = results[7];
                playerData.salaries = results[8];
                playerData.sneakers = results[9];
                playerData.comparisons = results[10];
                
                // Try to load All-Stars data (optional - for random comparison feature)
                try {
                    const allStarsResponse = await fetch(DATA_BASE_URL + DATA_FILES.allStarsData + cacheBust);
                    if (allStarsResponse.ok) {
                        playerData.allStarsData = await allStarsResponse.json();
                        console.log('All-Stars data loaded for random comparisons');
                    }
                } catch (e) {
                    console.log('All-Stars data not available - random comparison features disabled');
                    playerData.allStarsData = null;
                }
                
                console.log('Data loaded successfully:', {
                    comparisons: playerData.comparisons.length,
                    awards: playerData.awards.length,
                    rsStats: playerData.rsStats.length
                });
                
                // Debug: Check sample data structure
                if (playerData.rsStats.length > 0) {
                    console.log('Sample RS-Stats row:', playerData.rsStats[0]);
                }
                if (playerData.awards.length > 0) {
                    console.log('Sample Awards row:', playerData.awards[0]);
                }
                
                // Debug: Test LeBron James data
                const lebronRS = playerData.rsStats.filter(r => r.PLAYER && r.PLAYER.includes('LeBron'));
                const lebronAwards = playerData.awards.filter(r => r['PLAYER / COACH'] && r['PLAYER / COACH'].includes('LeBron'));
                console.log('LeBron RS-Stats rows:', lebronRS.length);
                console.log('LeBron Awards rows:', lebronAwards.length);
                if (lebronRS.length > 0) {
                    console.log('LeBron RS sample:', lebronRS[0]);
                }
                if (lebronAwards.length > 0) {
                    console.log('LeBron Award sample:', lebronAwards[0]);
                }
                
                // Extract unique players
                const playersSet = new Set();
                
                playerData.rsStats.forEach(row => {
                    if (row.PLAYER) playersSet.add(row.PLAYER.trim());
                });
                
                playerData.awards.forEach(row => {
                    if (row['PLAYER / COACH']) playersSet.add(row['PLAYER / COACH'].trim());
                });
                
                players = Array.from(playersSet).sort();
                dataLoaded = true;
                
                console.log(`Found ${players.length} unique players`);
                
                return Promise.resolve();
                
            } catch (error) {
                console.error('Error loading data:', error);
                throw error;
            }
        }

        // Initialize
        window.addEventListener('DOMContentLoaded', async function() {
            showLoading(true);
            
            try {
                await loadData();
                
                const urlParams = new URLSearchParams(window.location.search);
                const p1 = urlParams.get('p1');
                const p2 = urlParams.get('p2');
                
                setupAutocomplete();
                
                if (p1 && p2) {
                    // Load comparison from URL
                    const player1Name = formatPlayerName(p1);
                    const player2Name = formatPlayerName(p2);
                    
                    document.getElementById('player1-top').value = player1Name;
                    document.getElementById('player2-top').value = player2Name;
                    document.getElementById('player1-bottom').value = player1Name;
                    document.getElementById('player2-bottom').value = player2Name;
                    
                    setTimeout(() => compareFromInputs(), 500);
                } else {
                    // Load random All-Star comparison
                    const randomP1 = getRandomAllStar();
                    const randomP2 = getRandomAllStar();
                    
                    if (randomP1 && randomP2 && randomP1 !== randomP2) {
                        document.getElementById('player1-top').value = randomP1;
                        document.getElementById('player2-top').value = randomP2;
                        document.getElementById('player1-bottom').value = randomP1;
                        document.getElementById('player2-bottom').value = randomP2;
                        setTimeout(() => compareFromInputs(), 500);
                    }
                }
                
                showLoading(false);
                document.getElementById('mainContent').style.display = 'block';
            } catch (error) {
                showError('Failed to load player data. Error: ' + error.message);
                showLoading(false);
            }
        });

        function showLoading(show) {
            document.getElementById('loadingMessage').style.display = show ? 'block' : 'none';
        }

        function showError(message) {
            const errorDiv = document.getElementById('errorMessage');
            errorDiv.className = 'error-message';
            errorDiv.textContent = message;
            errorDiv.style.display = 'block';
        }

        function formatPlayerName(urlName) {
            return urlName.split('-').map(word => 
                word.charAt(0).toUpperCase() + word.slice(1).toLowerCase()
            ).join(' ');
        }

        function playerNameToURL(playerName) {
            return playerName.toLowerCase()
                .replace(/\s+/g, '-')
                .replace(/[^a-z0-9-]/g, '')
                .replace(/--+/g, '-');
        }

        function getRandomAllStar() {
            if (!playerData.allStarsData || !playerData.allStarsData.allStars1990Plus) return null;
            const allStars = playerData.allStarsData.allStars1990Plus;
            return allStars[Math.floor(Math.random() * allStars.length)];
        }

        function getSameEraAllStar(playerName) {
            if (!playerData.allStarsData || !playerData.allStarsData.playerDebutYears) return getRandomAllStar();
            
            const debutYears = playerData.allStarsData.playerDebutYears;
            // Use ALL All-Stars (all eras) for same-era suggestions
            const allStarsList = playerData.allStarsData.allStarsAllEras || playerData.allStarsData.allStars1990Plus || [];
            const playerDebutYear = debutYears[playerName];
            
            if (!playerDebutYear) return getRandomAllStar();
            
            // Get ALL-STARS from any era within ¬±8 years of debut
            const candidates = allStarsList.filter(p => {
                const pDebut = debutYears[p];
                if (!pDebut) return false;
                const yearDiff = Math.abs(pDebut - playerDebutYear);
                return yearDiff <= 8 && p !== playerName;
            });
            
            if (candidates.length === 0) return getRandomAllStar();
            
            return candidates[Math.floor(Math.random() * candidates.length)];
        }

        function makePlayerNamesClickable() {
            // Make all player names in the page clickable
            const resultsDiv = document.getElementById('results');
            if (!resultsDiv) return;
            
            const playerValueDivs = resultsDiv.querySelectorAll('.player-value');
            playerValueDivs.forEach(div => {
                const text = div.textContent.trim();
                // Check if it's a player name (not a stat value)
                if (text && players.includes(text)) {
                    div.style.cursor = 'pointer';
                    div.style.textDecoration = 'underline';
                    div.setAttribute('data-player-name', text);
                    
                    div.addEventListener('click', () => {
                        const clickedPlayer = div.getAttribute('data-player-name');
                        const currentP1 = document.getElementById('player1-top').value;
                        const currentP2 = document.getElementById('player2-top').value;
                        
                        // Keep clicked player in position, randomize opponent
                        if (clickedPlayer === currentP1) {
                            // Player 1 was clicked, randomize Player 2
                            const newP2 = getRandomAllStar();
                            if (newP2 && newP2 !== clickedPlayer) {
                                document.getElementById('player2-top').value = newP2;
                                document.getElementById('player2-bottom').value = newP2;
                                compareFromInputs();
                            }
                        } else if (clickedPlayer === currentP2) {
                            // Player 2 was clicked, randomize Player 1
                            const newP1 = getRandomAllStar();
                            if (newP1 && newP1 !== clickedPlayer) {
                                document.getElementById('player1-top').value = newP1;
                                document.getElementById('player1-bottom').value = newP1;
                                compareFromInputs();
                            }
                        }
                    });
                }
            });
        }

        function setupAutocomplete() {
            // Setup autocomplete for all 4 inputs (top and bottom)
            const inputs = [
                { input: 'player1-top', suggestions: 'suggestions1-top' },
                { input: 'player2-top', suggestions: 'suggestions2-top' },
                { input: 'player1-bottom', suggestions: 'suggestions1-bottom' },
                { input: 'player2-bottom', suggestions: 'suggestions2-bottom' }
            ];
            
            inputs.forEach(config => {
                const inputEl = document.getElementById(config.input);
                const suggestionsEl = document.getElementById(config.suggestions);
                
                inputEl.addEventListener('input', function() {
                    const value = this.value.toLowerCase();
                    
                    if (value.length < 2) {
                        suggestionsEl.style.display = 'none';
                        return;
                    }
                    
                    // Match on both exact and normalized names (handles apostrophes)
                    const normalizedValue = normalizePlayerName(value);
                    const matches = players.filter(p => 
                        p.toLowerCase().includes(value) || 
                        normalizePlayerName(p).includes(normalizedValue)
                    ).slice(0, 10); // Limit to 10 suggestions
                    
                    if (matches.length === 0) {
                        suggestionsEl.style.display = 'none';
                        return;
                    }
                    
                    suggestionsEl.innerHTML = matches.map(player => 
                        `<div class="autocomplete-suggestion" data-player="${player}">${player}</div>`
                    ).join('');
                    
                    suggestionsEl.style.display = 'block';
                    
                    // Add click handlers to suggestions
                    suggestionsEl.querySelectorAll('.autocomplete-suggestion').forEach(el => {
                        el.addEventListener('click', function() {
                            inputEl.value = this.getAttribute('data-player');
                            suggestionsEl.style.display = 'none';
                            
                            // Sync with other input
                            if (config.input.includes('top')) {
                                const bottomId = config.input.replace('top', 'bottom');
                                document.getElementById(bottomId).value = inputEl.value;
                            } else {
                                const topId = config.input.replace('bottom', 'top');
                                document.getElementById(topId).value = inputEl.value;
                            }
                            
                            updateShareURL();
                        });
                    });
                });
                
                // Close suggestions when clicking outside
                document.addEventListener('click', function(e) {
                    if (!inputEl.contains(e.target) && !suggestionsEl.contains(e.target)) {
                        suggestionsEl.style.display = 'none';
                    }
                });
            });
        }

        function updateShareURL() {
            const p1 = document.getElementById('player1-top').value;
            const p2 = document.getElementById('player2-top').value;
            
            if (p1 && p2) {
                const shareURL = `${window.location.origin}${window.location.pathname}?p1=${playerNameToURL(p1)}&p2=${playerNameToURL(p2)}`;
                return shareURL;
            }
            return '';
        }

        function normalizePlayerName(name) {
            // Normalize by removing apostrophes, spaces, and converting to lowercase
            return name.toLowerCase().replace(/['\s.-]/g, '');
        }

        function findPlayerName(inputName) {
            // First try exact match
            if (players.includes(inputName)) {
                return inputName;
            }
            
            // Then try normalized match
            const normalized = normalizePlayerName(inputName);
            for (let player of players) {
                if (normalizePlayerName(player) === normalized) {
                    return player;
                }
            }
            
            return null;
        }

        function compareFromInputs() {
            const p1Input = document.getElementById('player1-top').value.trim();
            const p2Input = document.getElementById('player2-top').value.trim();
            
            if (!p1Input || !p2Input) {
                alert('Please enter both player names');
                return;
            }
            
            // Find actual player names (handles apostrophes and special characters)
            const p1 = findPlayerName(p1Input);
            const p2 = findPlayerName(p2Input);
            
            if (!p1) {
                alert(`Player "${p1Input}" not found. Please select from suggestions.`);
                return;
            }
            
            if (!p2) {
                alert(`Player "${p2Input}" not found. Please select from suggestions.`);
                return;
            }
            
            if (p1 === p2) {
                alert('Please select different players');
                return;
            }
            
            // Update inputs with actual player names
            document.getElementById('player1-top').value = p1;
            document.getElementById('player2-top').value = p2;
            document.getElementById('player1-bottom').value = p1;
            document.getElementById('player2-bottom').value = p2;
            
            comparePlayer(p1, p2);
        }

        function comparePlayer(player1Name, player2Name) {
            const resultsDiv = document.getElementById('results');
            resultsDiv.innerHTML = '<div class="loading"><div class="spinner"></div><div>Comparing players...</div></div>';
            
            setTimeout(() => {
                const results = performComparison(player1Name, player2Name);
                displayResults(results, player1Name, player2Name);
                
                const newURL = `${window.location.pathname}?p1=${playerNameToURL(player1Name)}&p2=${playerNameToURL(player2Name)}`;
                window.history.pushState({}, '', newURL);
            }, 100);
        }

        function parseNumericValue(value) {
            // Helper function to convert values to numbers for comparison
            if (!value) return NaN;
            
            const strValue = String(value);
            
            // Check if it's in feet-inches format (e.g., "6' 7.25''")
            const feetInchesMatch = strValue.match(/(\d+)'\s*([\d.]+)['"]+/);
            if (feetInchesMatch) {
                const feet = parseFloat(feetInchesMatch[1]);
                const inches = parseFloat(feetInchesMatch[2]);
                return (feet * 12) + inches; // Convert to total inches
            }
            
            // Otherwise strip currency symbols and commas
            return parseFloat(strValue.replace(/[\$,]/g, ''));
        }

        function performComparison(player1Name, player2Name) {
            let player1Score = 0;
            let player2Score = 0;
            const categories = {};
            const sectionScores = {}; // Track scores per section
            let currentSection = null;
            
            // Sections that award points even when opponent has no data
            const alwaysAwardSections = [
                'ACCOLADES', 
                'BEST AWARDS RANKING', 
                'YEARS RECEIVING VOTES', 
                'SIGNATURE SHOES'
            ];
            
            // Sections that require BOTH players to have data (like DRAFT COMBINE but counts toward overall)
            const requireBothDataSections = [
                'SALARIES',
                'NBA 2K'
            ];
            
            // Sections excluded from overall score
            const excludeFromOverall = ['DRAFT COMBINE'];
            
            playerData.comparisons.forEach(comp => {
                const category = comp['Comparison points'];
                const winCondition = comp['Who wins?'];
                const dataSource = comp['Wheres the data?'];
                
                // Check if this is a section header
                if (!winCondition && !dataSource) {
                    currentSection = category;
                    categories[currentSection] = [];
                    sectionScores[currentSection] = { player1: 0, player2: 0 };
                    return;
                }
                
                if (!currentSection || !category) return;
                
                // Get player stats
                const p1Value = getPlayerStat(player1Name, category, dataSource);
                const p2Value = getPlayerStat(player2Name, category, dataSource);
                
                // Determine winner
                let winner = 'tie';
                let awardPoint = false;
                
                // Check if this section always awards points
                const alwaysAward = alwaysAwardSections.includes(currentSection);
                
                // Check if this section requires both players to have data
                const requireBothData = requireBothDataSections.includes(currentSection) || 
                                       excludeFromOverall.includes(currentSection);
                
                if (p1Value !== null && p2Value !== null) {
                    // Both have data - normal comparison
                    const p1Num = parseNumericValue(p1Value);
                    const p2Num = parseNumericValue(p2Value);
                    
                    if (!isNaN(p1Num) && !isNaN(p2Num)) {
                        if (winCondition === 'Most') {
                            if (p1Num > p2Num) {
                                winner = 'player1';
                                awardPoint = true;
                            } else if (p2Num > p1Num) {
                                winner = 'player2';
                                awardPoint = true;
                            }
                        } else if (winCondition === 'Least') {
                            if (p1Num < p2Num) {
                                winner = 'player1';
                                awardPoint = true;
                            } else if (p2Num < p1Num) {
                                winner = 'player2';
                                awardPoint = true;
                            }
                        }
                        
                        // Check if this is an untracked stat (steals/blocks/turnovers/3P with a 0)
                        if (awardPoint) {
                            const untrackedSections = ['NBA CAREER AVERAGES', 'NBA CAREER TOTALS', 'NBA SEASON PEAK'];
                            const untrackedCategories = ['steals', 'steal', 'blocks', 'block', 'turnovers', 'turnover', 'three', '3p', 'stl', 'blk', 'tov'];
                            
                            const inUntrackedSection = untrackedSections.some(s => 
                                currentSection && currentSection.trim().toUpperCase() === s.toUpperCase()
                            );
                            
                            const isUntrackedCategory = untrackedCategories.some(c => 
                                category && category.toLowerCase().includes(c)
                            );
                            
                            // Check if value is zero - check both raw and parsed
                            const isZeroValue = (rawVal, numVal) => {
                                if (numVal === 0) return true;
                                const strVal = String(rawVal).trim();
                                if (strVal === '0' || strVal === '0.0' || strVal === '0.00') return true;
                                return parseFloat(strVal) === 0;
                            };
                            
                            const p1IsZero = isZeroValue(p1Value, p1Num);
                            const p2IsZero = isZeroValue(p2Value, p2Num);
                            
                            // DEBUG - log when we're checking untracked stats
                            if (inUntrackedSection && isUntrackedCategory) {
                                console.log('UNTRACKED STAT CHECK:', {
                                    section: currentSection,
                                    category: category,
                                    p1Value: p1Value,
                                    p1Num: p1Num,
                                    p1IsZero: p1IsZero,
                                    p2Value: p2Value,
                                    p2Num: p2Num,
                                    p2IsZero: p2IsZero,
                                    willCancelPoint: p1IsZero || p2IsZero
                                });
                            }
                            
                            // If either player has 0, don't award the point (stat wasn't tracked for them)
                            if (inUntrackedSection && isUntrackedCategory) {
                                if (p1IsZero || p2IsZero) {
                                    awardPoint = false;
                                }
                            }
                        }
                    }
                } else if (alwaysAward && !requireBothData) {
                    // Only one has data - award point if in special sections (and not requiring both)
                    if (p1Value !== null && p2Value === null) {
                        const p1Num = parseNumericValue(p1Value);
                        if (!isNaN(p1Num) && p1Num > 0) {
                            winner = 'player1';
                            awardPoint = true;
                        }
                    } else if (p2Value !== null && p1Value === null) {
                        const p2Num = parseNumericValue(p2Value);
                        if (!isNaN(p2Num) && p2Num > 0) {
                            winner = 'player2';
                            awardPoint = true;
                        }
                    }
                }
                
                // Award points
                if (awardPoint) {
                    if (winner === 'player1') {
                        sectionScores[currentSection].player1++;
                        // Add to overall score unless it's an excluded section
                        if (!excludeFromOverall.includes(currentSection)) {
                            player1Score++;
                        }
                    } else if (winner === 'player2') {
                        sectionScores[currentSection].player2++;
                        // Add to overall score unless it's an excluded section
                        if (!excludeFromOverall.includes(currentSection)) {
                            player2Score++;
                        }
                    }
                }
                
                categories[currentSection].push({
                    metric: category,
                    player1Value: p1Value,
                    player2Value: p2Value,
                    winner: winner
                });
            });
            
            // Remove empty comparisons (where both players have no data)
            Object.keys(categories).forEach(sectionName => {
                categories[sectionName] = categories[sectionName].filter(item => 
                    item.player1Value !== null || item.player2Value !== null
                );
            });
            
            return {
                player1: player1Name,
                player2: player2Name,
                player1Score: player1Score,
                player2Score: player2Score,
                categories: categories,
                sectionScores: sectionScores
            };
        }

        function getPlayerStat(playerName, metric, dataSource) {
            if (!dataSource) return null;
            
            // Map metric to actual data field based on data source
            if (dataSource === 'Awards.csv') {
                return getAwardCount(playerName, metric);
            } else if (dataSource === 'RS-Stats.csv') {
                return getRegularSeasonStat(playerName, metric);
            } else if (dataSource === 'PO-Stats.csv') {
                return getPlayoffStat(playerName, metric);
            } else if (dataSource === 'PO-series.csv') {
                return getPlayoffSeriesStat(playerName, metric);
            } else if (dataSource === 'Salaries.csv') {
                return getSalaryStat(playerName, metric);
            } else if (dataSource === 'Combine.csv') {
                return getCombineStat(playerName, metric);
            } else if (dataSource === 'Award-Votes.csv') {
                return getVotingStat(playerName, metric);
            } else if (dataSource === 'Sneakers.csv') {
                return getSneakerCount(playerName);
            } else if (dataSource === 'NBA2K.csv') {
                return get2KRating(playerName, metric);
            } else if (dataSource === 'All-Star.csv') {
                return getAllStarContestWins(playerName, metric);
            }
            
            return null;
        }

        function getAwardCount(playerName, awardType) {
            // Handle combined awards
            if (awardType === 'All-NBA Selections') {
                const first = playerData.awards.filter(row => 
                    row['PLAYER / COACH'] === playerName && row.AWARD === 'All-NBA First Team'
                ).length;
                const second = playerData.awards.filter(row => 
                    row['PLAYER / COACH'] === playerName && row.AWARD === 'All-NBA Second Team'
                ).length;
                const third = playerData.awards.filter(row => 
                    row['PLAYER / COACH'] === playerName && row.AWARD === 'All-NBA Third Team'
                ).length;
                const total = first + second + third;
                return total > 0 ? total : null;
            }
            
            if (awardType === 'All-Defensive Team Selections') {
                const first = playerData.awards.filter(row => 
                    row['PLAYER / COACH'] === playerName && row.AWARD === 'All-Defensive First Team'
                ).length;
                const second = playerData.awards.filter(row => 
                    row['PLAYER / COACH'] === playerName && row.AWARD === 'All-Defensive Second Team'
                ).length;
                const total = first + second;
                return total > 0 ? total : null;
            }
            
            if (awardType === 'Olympic Medals') {
                const gold = playerData.awards.filter(row => 
                    row['PLAYER / COACH'] === playerName && row.AWARD === 'Olympic Gold'
                ).length;
                const silver = playerData.awards.filter(row => 
                    row['PLAYER / COACH'] === playerName && row.AWARD === 'Olympic Silver'
                ).length;
                const bronze = playerData.awards.filter(row => 
                    row['PLAYER / COACH'] === playerName && row.AWARD === 'Olympic Bronze'
                ).length;
                const total = gold + silver + bronze;
                return total > 0 ? total : null;
            }
            
            if (awardType === 'World Cup Medals') {
                const gold = playerData.awards.filter(row => 
                    row['PLAYER / COACH'] === playerName && row.AWARD === 'World Cup Gold'
                ).length;
                const silver = playerData.awards.filter(row => 
                    row['PLAYER / COACH'] === playerName && row.AWARD === 'World Cup Silver'
                ).length;
                const bronze = playerData.awards.filter(row => 
                    row['PLAYER / COACH'] === playerName && row.AWARD === 'World Cup Bronze'
                ).length;
                const total = gold + silver + bronze;
                return total > 0 ? total : null;
            }
            
            // Conference Finals MVP combines EC Finals MVP and WC Finals MVP
            if (awardType === 'Conference Finals MVP') {
                const ec = playerData.awards.filter(row => 
                    row['PLAYER / COACH'] === playerName && row.AWARD === 'EC Finals MVP'
                ).length;
                const wc = playerData.awards.filter(row => 
                    row['PLAYER / COACH'] === playerName && row.AWARD === 'WC Finals MVP'
                ).length;
                const total = ec + wc;
                return total > 0 ? total : null;
            }
            
            // Regular award count
            const playerAwards = playerData.awards.filter(row => 
                row['PLAYER / COACH'] === playerName && row.AWARD === awardType
            );
            return playerAwards.length > 0 ? playerAwards.length : null;
        }

        function getRegularSeasonStat(playerName, metric) {
            const playerRows = playerData.rsStats.filter(row => row.PLAYER === playerName);
            if (playerRows.length === 0) return null;
            
            // Map metric to column name
            const columnMap = {
                'Points per game': 'PTS / G',
                'Rebounds per game': 'REB / G',
                'Assists per game': 'AST / G',
                'Steals per game': 'STL / G',
                'Blocks per game': 'BLK / G',
                'Field Goal %': 'FG%',
                'Three Point %': '3P%',
                'Free Throw %': 'FT%',
                'Turnovers per game': 'TOV / G',
                'Games': 'GP',
                'Points': 'PTS',
                'Rebounds': 'REB',
                'Assists': 'AST',
                'Steals': 'STL',
                'Blocks': 'BLK',
                'Turnovers': 'TOV',
                '3P%': '3P%'
            };
            
            // Season peak metrics - find highest single-season average
            const peakMetrics = {
                'Points per game peak': 'PTS / G',
                'Rebounds per game peak': 'REB / G',
                'Assists per game peak': 'AST / G',
                'Steals per game peak': 'STL / G',
                'Blocks per game peak': 'BLK / G',
                'Field Goal % peak': 'FG%',
                'Three Point % peak': '3P%',
                'Free Throw % peak': 'FT%',
                'Turnovers per game peak': 'TOV / G'
            };
            
            // Check if this is a peak metric
            if (peakMetrics[metric]) {
                const column = peakMetrics[metric];
                
                // For percentage peaks, calculate from makes/attempts for each season
                if (metric.includes('%')) {
                    let maxPct = -Infinity;
                    
                    const pctMap = {
                        'Field Goal % peak': { made: 'FGM', att: 'FGA' },
                        'Three Point % peak': { made: '3P', att: '3PA' },
                        'Free Throw % peak': { made: 'FTM', att: 'FTA' }
                    };
                    
                    const pctInfo = pctMap[metric];
                    if (pctInfo) {
                        playerRows.forEach(row => {
                            const made = parseFloat(row[pctInfo.made]);
                            const att = parseFloat(row[pctInfo.att]);
                            
                            // Only calculate if player had attempts
                            if (!isNaN(made) && !isNaN(att) && att > 0) {
                                const pct = (made / att) * 100;
                                if (pct > maxPct) {
                                    maxPct = pct;
                                }
                            }
                        });
                        
                        return maxPct > -Infinity ? maxPct.toFixed(1) + '%' : null;
                    }
                }
                
                // For non-percentage peaks, find max value
                let maxValue = -Infinity;
                
                playerRows.forEach(row => {
                    let val = row[column];
                    
                    if (typeof val === 'string') {
                        val = val.replace('%', '');
                    }
                    
                    val = parseFloat(val);
                    
                    if (!isNaN(val) && val > maxValue) {
                        maxValue = val;
                    }
                });
                
                if (maxValue > -Infinity) {
                    return maxValue.toFixed(1);
                }
                return null;
            }
            
            const column = columnMap[metric];
            if (!column) return null;
            
            // For per-game stats, calculate total/games
            if (metric.includes('per game')) {
                const baseStatMap = {
                    'Points per game': 'PTS',
                    'Rebounds per game': 'REB',
                    'Assists per game': 'AST',
                    'Steals per game': 'STL',
                    'Blocks per game': 'BLK',
                    'Turnovers per game': 'TOV'
                };
                
                const totalColumn = baseStatMap[metric];
                if (!totalColumn) return null;
                
                let totalStat = 0;
                let totalGames = 0;
                
                playerRows.forEach(row => {
                    const stat = parseFloat(row[totalColumn]);
                    const games = parseFloat(row['GP']);
                    if (!isNaN(stat) && !isNaN(games)) {
                        totalStat += stat;
                        totalGames += games;
                    }
                });
                
                return totalGames > 0 ? (totalStat / totalGames).toFixed(1) : null;
            }
            
            // For percentages, calculate weighted average
            if (metric.includes('%')) {
                const percentageMap = {
                    'Field Goal %': { pct: 'FG%', made: 'FGM', att: 'FGA' },
                    'Three Point %': { pct: '3P%', made: '3P', att: '3PA' },
                    'Free Throw %': { pct: 'FT%', made: 'FTM', att: 'FTA' },
                    '3P%': { pct: '3P%', made: '3P', att: '3PA' }
                };
                
                const pctInfo = percentageMap[metric];
                if (!pctInfo) return null;
                
                let totalMade = 0;
                let totalAtt = 0;
                
                playerRows.forEach(row => {
                    const made = parseFloat(row[pctInfo.made]);
                    const att = parseFloat(row[pctInfo.att]);
                    if (!isNaN(made) && !isNaN(att)) {
                        totalMade += made;
                        totalAtt += att;
                    }
                });
                
                if (totalAtt > 0) {
                    const pct = (totalMade / totalAtt) * 100;
                    return pct.toFixed(1) + '%';
                }
                return null;
            }
            
            // For totals, sum up
            let total = 0;
            playerRows.forEach(row => {
                const val = parseFloat(row[column]);
                if (!isNaN(val)) {
                    total += val;
                }
            });
            return total > 0 ? Math.round(total) : null;
        }

        function getPlayoffStat(playerName, metric) {
            const playerRows = playerData.poStats.filter(row => row.PLAYER === playerName);
            if (playerRows.length === 0) return null;
            
            // Similar to regular season stats
            const columnMap = {
                'Points per game PO': 'PTS / G',
                'Rebounds per game PO': 'REB / G',
                'Assists per game PO': 'AST / G',
                'Steals per game PO': 'STL / G',
                'Blocks per game PO': 'BLK / G',
                'Field Goal % PO': 'FG%',
                'Three Point % PO': '3P%',
                'Free Throw % PO': 'FT%',
                'Turnovers per game PO': 'TOV / G',
                'Games PO': 'GP',
                'Points PO': 'PTS',
                'Rebounds PO': 'REB',
                'Assists PO': 'AST',
                'Steals PO': 'STL',
                'Blocks PO': 'BLK',
                'Turnovers PO': 'TOV'
            };
            
            // Playoff peak metrics - find highest single-postseason average
            const peakMetrics = {
                'Points per game PO peak': 'PTS / G',
                'Rebounds per game PO peak': 'REB / G',
                'Assists per game PO peak': 'AST / G',
                'Steals per game PO peak': 'STL / G',
                'Blocks per game PO peak': 'BLK / G',
                'Field Goal % PO peak': 'FG%',
                'Three Point % PO peak': '3P%',
                'Free Throw % PO peak': 'FT%',
                'Turnovers per game PO peak': 'TOV / G'
            };
            
            // Check if this is a peak metric
            if (peakMetrics[metric]) {
                const column = peakMetrics[metric];
                
                // For percentage peaks, calculate from makes/attempts for each season
                if (metric.includes('%')) {
                    let maxPct = -Infinity;
                    
                    const pctMap = {
                        'Field Goal % PO peak': { made: 'FGM', att: 'FGA' },
                        'Three Point % PO peak': { made: '3:00 PM', att: '3PA' },
                        'Free Throw % PO peak': { made: 'FTM', att: 'FTA' }
                    };
                    
                    const pctInfo = pctMap[metric];
                    if (pctInfo) {
                        playerRows.forEach(row => {
                            const made = parseFloat(row[pctInfo.made]);
                            const att = parseFloat(row[pctInfo.att]);
                            
                            // Only calculate if player had attempts
                            if (!isNaN(made) && !isNaN(att) && att > 0) {
                                const pct = (made / att) * 100;
                                if (pct > maxPct) {
                                    maxPct = pct;
                                }
                            }
                        });
                        
                        return maxPct > -Infinity ? maxPct.toFixed(1) + '%' : null;
                    }
                }
                
                // For non-percentage peaks, find max value
                let maxValue = -Infinity;
                
                playerRows.forEach(row => {
                    let val = row[column];
                    
                    if (typeof val === 'string') {
                        val = val.replace('%', '');
                    }
                    
                    val = parseFloat(val);
                    
                    if (!isNaN(val) && val > maxValue) {
                        maxValue = val;
                    }
                });
                
                if (maxValue > -Infinity) {
                    return maxValue.toFixed(1);
                }
                return null;
            }
            
            const column = columnMap[metric];
            if (!column) return null;
            
            // For per-game stats, calculate total/games
            if (metric.includes('per game')) {
                const baseStatMap = {
                    'Points per game PO': 'PTS',
                    'Rebounds per game PO': 'REB',
                    'Assists per game PO': 'AST',
                    'Steals per game PO': 'STL',
                    'Blocks per game PO': 'BLK',
                    'Turnovers per game PO': 'TOV'
                };
                
                const totalColumn = baseStatMap[metric];
                if (!totalColumn) return null;
                
                let totalStat = 0;
                let totalGames = 0;
                
                playerRows.forEach(row => {
                    const stat = parseFloat(row[totalColumn]);
                    const games = parseFloat(row['GP']);
                    if (!isNaN(stat) && !isNaN(games)) {
                        totalStat += stat;
                        totalGames += games;
                    }
                });
                
                return totalGames > 0 ? (totalStat / totalGames).toFixed(1) : null;
            }
            
            // For percentages, calculate weighted average
            if (metric.includes('%')) {
                const percentageMap = {
                    'Field Goal % PO': { pct: 'FG%', made: 'FGM', att: 'FGA' },
                    'Three Point % PO': { pct: '3P%', made: '3:00 PM', att: '3PA' },
                    'Free Throw % PO': { pct: 'FT%', made: 'FTM', att: 'FTA' }
                };
                
                const pctInfo = percentageMap[metric];
                if (!pctInfo) return null;
                
                let totalMade = 0;
                let totalAtt = 0;
                
                playerRows.forEach(row => {
                    const made = parseFloat(row[pctInfo.made]);
                    const att = parseFloat(row[pctInfo.att]);
                    if (!isNaN(made) && !isNaN(att)) {
                        totalMade += made;
                        totalAtt += att;
                    }
                });
                
                if (totalAtt > 0) {
                    const pct = (totalMade / totalAtt) * 100;
                    return pct.toFixed(1) + '%';
                }
                return null;
            }
            
            // For totals, sum up
            let total = 0;
            playerRows.forEach(row => {
                const val = parseFloat(row[column]);
                if (!isNaN(val)) {
                    total += val;
                }
            });
            return total > 0 ? Math.round(total) : null;
        }

        function getPlayoffSeriesStat(playerName, metric) {
            // Get all playoff rows for this player from poStats
            // Note: poStats uses "PLAYER" field, not "NAME"
            const playerRows = playerData.poStats.filter(row => row.PLAYER === playerName);
            if (playerRows.length === 0) return null;
            
            // Count each result type
            const resultCounts = {
                'First Round': 0,
                'Conf Semis': 0,
                'Conf Finalist': 0,
                'Finalist': 0,
                'Champion': 0
            };
            
            playerRows.forEach(row => {
                const result = row.RESULT;
                if (resultCounts.hasOwnProperty(result)) {
                    resultCounts[result]++;
                }
            });
            
            // For playoff success metrics, calculate cumulative counts
            // If you reached Champion, you also reached all earlier rounds that year
            if (metric === 'Champion') {
                return resultCounts['Champion'] > 0 ? resultCounts['Champion'] : null;
            }
            
            if (metric === 'Finalist') {
                const count = resultCounts['Finalist'] + resultCounts['Champion'];
                return count > 0 ? count : null;
            }
            
            if (metric === 'Conference Finals') {
                const count = resultCounts['Conf Finalist'] + resultCounts['Finalist'] + resultCounts['Champion'];
                return count > 0 ? count : null;
            }
            
            if (metric === 'Conference Semis') {
                const count = resultCounts['Conf Semis'] + resultCounts['Conf Finalist'] + resultCounts['Finalist'] + resultCounts['Champion'];
                return count > 0 ? count : null;
            }
            
            if (metric === 'First Round') {
                const count = resultCounts['First Round'] + resultCounts['Conf Semis'] + resultCounts['Conf Finalist'] + resultCounts['Finalist'] + resultCounts['Champion'];
                return count > 0 ? count : null;
            }
            
            // For other playoff series stats, use poSeries data
            const playerSeriesRow = playerData.poSeries.find(row => row.NAME === playerName);
            if (!playerSeriesRow) return null;
            
            if (metric === 'Playoff series played') {
                return playerSeriesRow.TOT || null;
            }
            
            if (metric === 'Playoff series won') {
                return playerSeriesRow.W || null;
            }
            
            if (metric === 'Playoff series win %') {
                return playerSeriesRow['% W'] || null;
            }
            
            return null;
        }

        function getSalaryStat(playerName, metric) {
            const playerRows = playerData.salaries.filter(row => row.PLAYER === playerName);
            if (playerRows.length === 0) return null;
            
            // Group by year to avoid counting same salary multiple times in one season
            const salariesByYear = {};
            playerRows.forEach(row => {
                const year = row.YEAR;
                const salary = parseFloat(String(row.SALARY || '').replace(/[$,]/g, ''));
                
                if (!isNaN(salary) && salary > 0 && year) {
                    // Keep track of salaries per year, store in array in case of mid-season trades
                    if (!salariesByYear[year]) {
                        salariesByYear[year] = [];
                    }
                    salariesByYear[year].push(salary);
                }
            });
            
            // For each year, sum all salaries (in case of mid-season trades)
            const yearlyTotals = [];
            for (const year in salariesByYear) {
                const yearTotal = salariesByYear[year].reduce((sum, val) => sum + val, 0);
                yearlyTotals.push(yearTotal);
            }
            
            if (yearlyTotals.length === 0) return null;
            
            if (metric === 'Career earnings') {
                const total = yearlyTotals.reduce((sum, val) => sum + val, 0);
                return '$' + Math.round(total).toLocaleString();
            }
            
            if (metric === 'Average salary') {
                const avg = yearlyTotals.reduce((sum, val) => sum + val, 0) / yearlyTotals.length;
                return '$' + Math.round(avg).toLocaleString();
            }
            
            if (metric === 'Highest salary') {
                const max = Math.max(...yearlyTotals);
                return '$' + Math.round(max).toLocaleString();
            }
            
            if (metric === 'Lowest salary') {
                const min = Math.min(...yearlyTotals);
                return '$' + Math.round(min).toLocaleString();
            }
            
            return null;
        }

        function getCombineStat(playerName, metric) {
            const playerRow = playerData.combine.find(row => row.PLAYER === playerName);
            if (!playerRow) return null;
            
            const columnMap = {
                'Body fat': 'BODY FAT %',
                'Hand size': 'HAND SIZE',
                'Height without shoes': 'HEIGHT W/O SHOES',
                'Standing reach': 'STANDING REACH',
                'Standing reach (inches)': 'STANDING',
                'Weight': 'WEIGHT (LBS)',
                'Wingspan': 'WINGSPAN',
                'Lane agility time': 'LANE AGILITY',
                'Shuttle run': 'SHUTTLE RUN',
                'Three quarter sprint': '3/4 SPRINT',
                'Standing vertical leap': 'STANDING VERT',
                'Max vertical leap': 'MAX VERT',
                'Max bench press': 'MAX BENCH',
                'Height': 'HEIGHT'
            };
            
            const column = columnMap[metric];
            if (!column) return null;
            
            let value = playerRow[column];
            if (!value || value.trim() === '') return null;
            
            // Convert HEIGHT and STANDING from inches to feet-inches format
            if (metric === 'Height' || metric === 'Standing reach (inches)') {
                const inches = parseFloat(value);
                if (!isNaN(inches)) {
                    const feet = Math.floor(inches / 12);
                    const remainingInches = inches % 12;
                    value = `${feet}' ${remainingInches.toFixed(2)}''`;
                }
            }
            
            return value;
        }

        function getVotingStat(playerName, metric) {
            const playerVotes = playerData.awardVotes.filter(row => row.PLAYER === playerName);
            
            // Best awards ranking - find lowest (best) rank for each award
            const awardRankingMap = {
                'Most Valuable Player': 'MVP',
                'Defensive Player of the Year': 'DPOY',
                'Rookie of the Year': 'ROY',
                'Most Improved Player': 'MIP',
                'Clutch Player of the Year': 'Clutch',
                'Sixth Man of the Year': 'Sixth Man',
                'Hustle Award': 'Hustle'
            };
            
            if (awardRankingMap[metric]) {
                const awardType = awardRankingMap[metric];
                const relevantVotes = playerVotes.filter(row => row.AWARD === awardType);
                
                if (relevantVotes.length === 0) return null;
                
                let bestRank = Infinity;
                relevantVotes.forEach(row => {
                    const rank = parseInt(row.RNK);
                    if (!isNaN(rank) && rank < bestRank) {
                        bestRank = rank;
                    }
                });
                
                return bestRank < Infinity ? bestRank : null;
            }
            
            // Years receiving votes
            const yearsVotesMap = {
                'Years with MVP votes': 'MVP',
                'Years with DPOY votes': 'DPOY',
                'Years with ROY votes': 'ROY',
                'Years with Sixth Man votes': 'Sixth Man',
                'Years with MIP votes': 'MIP',
                'Years with Clutch Player votes': 'Clutch',
                'Years with Hustle Award votes': 'Hustle'
            };
            
            if (yearsVotesMap[metric]) {
                const awardType = yearsVotesMap[metric];
                const relevantVotes = playerVotes.filter(row => row.AWARD === awardType);
                return relevantVotes.length > 0 ? relevantVotes.length : null;
            }
            
            return null;
        }

        function getSneakerCount(playerName) {
            const playerRow = playerData.sneakers.find(row => row.Player === playerName);
            return playerRow ? playerRow['# of shoes'] : null;
        }

        function get2KRating(playerName, metric) {
            const playerRow = playerData.nba2k.find(row => 
                row['Full Name'] === playerName || 
                row['First Name'] + ' ' + row['Last Name'] === playerName
            );
            
            if (!playerRow) return null;
            
            // Collect all ratings
            const ratings = [];
            for (let key in playerRow) {
                if (key.startsWith('2K') || key.startsWith('2k')) {
                    const val = parseInt(playerRow[key]);
                    if (!isNaN(val)) {
                        ratings.push(val);
                    }
                }
            }
            
            if (ratings.length === 0) return null;
            
            if (metric === 'Average career rating') {
                const avg = ratings.reduce((sum, val) => sum + val, 0) / ratings.length;
                return avg.toFixed(1);
            }
            
            if (metric === 'Highest rating') {
                return Math.max(...ratings);
            }
            
            if (metric === 'Lowest rating') {
                return Math.min(...ratings);
            }
            
            return null;
        }

        function getAllStarContestWins(playerName, metric) {
            const playerWins = playerData.allStar.filter(row => 
                row.NAME === playerName && row['WINNER?'] === 'WINNER'
            );
            
            if (metric === 'Dunk Contest') {
                return playerWins.filter(r => r.CONTEST === 'Dunk Contest').length || null;
            } else if (metric === 'Three-Point Contest') {
                return playerWins.filter(r => r.CONTEST === 'Three-Point Contest').length || null;
            } else if (metric === 'Skills Challenge') {
                return playerWins.filter(r => r.CONTEST === 'Skills Challenge').length || null;
            }
            
            return null;
        }

        function displayResults(results, player1Name, player2Name) {
            const resultsDiv = document.getElementById('results');
            
            let html = `
                <div class="score-summary">
                    <div class="player-score">
                        <div class="player-name-score clickable-player-name" data-player-name="${player1Name}" style="cursor: pointer; text-decoration: underline;">${player1Name}</div>
                        <div class="score-value">${results.player1Score}</div>
                    </div>
                    <div class="score-divider">‚Äì</div>
                    <div class="player-score">
                        <div class="player-name-score clickable-player-name" data-player-name="${player2Name}" style="cursor: pointer; text-decoration: underline;">${player2Name}</div>
                        <div class="score-value">${results.player2Score}</div>
                    </div>
                </div>
            `;
            
            const shareURL = updateShareURL();
            html += `
                <div class="share-url">
                    <h3>üì§ Share This Comparison</h3>
                    <input type="text" class="share-url-input" value="${shareURL}" readonly onclick="this.select(); try { document.execCommand('copy'); alert('URL copied!'); } catch(e) { console.log('Copy failed'); }">
                </div>
            `;
            
            // Display categories
            Object.keys(results.categories).forEach(categoryName => {
                const items = results.categories[categoryName];
                if (items.length === 0) return;
                
                // Get section scores
                const sectionScore = results.sectionScores[categoryName];
                // Only show section score if at least one player has points
                const showScore = sectionScore && (sectionScore.player1 > 0 || sectionScore.player2 > 0);
                const sectionScoreHTML = showScore ? 
                    `<div class="section-score">
                        <span class="clickable-player-name" data-player-name="${player1Name}" style="cursor: pointer; text-decoration: underline;">${player1Name}</span> ${sectionScore.player1} ‚Äì 
                        <span class="clickable-player-name" data-player-name="${player2Name}" style="cursor: pointer; text-decoration: underline;">${player2Name}</span> ${sectionScore.player2}
                    </div>` : '';
                
                html += `<div class="category-section">
                    <div class="category-title">
                        ${categoryName}
                        ${sectionScoreHTML}
                    </div>`;
                
                items.forEach(item => {
                    const rowClass = item.winner === 'player1' ? 'winner-left' : 
                                    item.winner === 'player2' ? 'winner-right' : 'tie';
                    
                    const p1Class = item.winner === 'player1' ? 'player-value winner' : 'player-value';
                    const p2Class = item.winner === 'player2' ? 'player-value winner' : 'player-value';
                    
                    const p1Display = item.player1Value !== null ? item.player1Value : '<span class="no-data">‚Äì</span>';
                    const p2Display = item.player2Value !== null ? item.player2Value : '<span class="no-data">‚Äì</span>';
                    
                    html += `
                        <div class="comparison-row ${rowClass}">
                            <div class="${p1Class}">${p1Display}</div>
                            <div class="player-value" style="font-weight: normal; font-size: 16px;">${player1Name}</div>
                            <div class="metric-name">${item.metric}</div>
                            <div class="player-value" style="font-weight: normal; font-size: 16px;">${player2Name}</div>
                            <div class="${p2Class}">${p2Display}</div>
                        </div>
                    `;
                });
                
                html += `</div>`;
            });
            
            // Add same-era suggestion button (only if All-Stars data is available)
            const sameEraP1 = getSameEraAllStar(player1Name);
            const sameEraP2 = getSameEraAllStar(player2Name);
            
            if (sameEraP1 && sameEraP2) {
                html += `
                    <div class="suggestions-section">
                        <h3 style="margin-bottom: 15px; color: #1a1a1a;">‚ú® Try These Comparisons</h3>
                        <div style="display: flex; gap: 15px; flex-wrap: wrap;">
                            <button class="suggestion-btn" data-p1="${player1Name}" data-p2="${sameEraP1}">
                                ${player1Name} vs ${sameEraP1}
                            </button>
                            <button class="suggestion-btn" data-p1="${player2Name}" data-p2="${sameEraP2}">
                                ${player2Name} vs ${sameEraP2}
                            </button>
                        </div>
                    </div>
                `;
            }
            
            resultsDiv.innerHTML = html;
            
            // Attach click handlers to clickable player names in scoreboards
            resultsDiv.querySelectorAll('.clickable-player-name').forEach(nameEl => {
                nameEl.addEventListener('click', function() {
                    const clickedPlayer = this.getAttribute('data-player-name');
                    const currentP1 = document.getElementById('player1-top').value;
                    const currentP2 = document.getElementById('player2-top').value;
                    
                    // Keep clicked player in position, randomize opponent
                    if (clickedPlayer === currentP1) {
                        // Player 1 was clicked, randomize Player 2
                        const newP2 = getRandomAllStar();
                        if (newP2 && newP2 !== clickedPlayer) {
                            document.getElementById('player2-top').value = newP2;
                            document.getElementById('player2-bottom').value = newP2;
                            compareFromInputs();
                        }
                    } else if (clickedPlayer === currentP2) {
                        // Player 2 was clicked, randomize Player 1
                        const newP1 = getRandomAllStar();
                        if (newP1 && newP1 !== clickedPlayer) {
                            document.getElementById('player1-top').value = newP1;
                            document.getElementById('player1-bottom').value = newP1;
                            compareFromInputs();
                        }
                    }
                });
            });
            
            // Attach click handlers to suggestion buttons
            resultsDiv.querySelectorAll('.suggestion-btn').forEach(btn => {
                btn.addEventListener('click', function() {
                    const p1 = this.getAttribute('data-p1');
                    const p2 = this.getAttribute('data-p2');
                    loadComparison(p1, p2);
                });
            });
            
            // Make player names clickable
            makePlayerNamesClickable();
        }
        
        function loadComparison(p1, p2) {
            document.getElementById('player1-top').value = p1;
            document.getElementById('player2-top').value = p2;
            document.getElementById('player1-bottom').value = p1;
            document.getElementById('player2-bottom').value = p2;
            compareFromInputs();
        }
    </script>
</body>
</html>
